---
title: "Journal de Xingyu LIU et de Xiaoou WANG"
Author: "Liu/Wang"
output:
    html_document:
        toc: true
        toc_float: true
---
<br>

## 25/09/19 - Préambule Unix I

<center><font size="3" color="blue">Système de fichiers</font></center>
<br>
Sous windows, il y a plusieurs arborescences tandis que sous unix, on a qu’une arborescence.

```{bash echo=TRUE}
pwd # print repertoire actuel
cd .. # remonte au repertoire parent
cd / # aller a la racine
echo "# exemple de l'arborescence de la racine sous Mac"
ls # exemple de l'arborescence de la racine sous Mac
cd ~ # aller a home
echo "# sortie de la commande cat"
cat test.txt # visualiser le contenu d'un fichier
echo "# montrer les metadonnes du contenu"
wc test.txt # la commande egale wc -mlw, m = caractere l = ligne, w = mots
```

## 02/10/19 - Préambule Unix II 

<center><font size="3" color="blue">1. Flux d'entrée & de sortie & d'erreur</font></center>

```{bash echo=TRUE}
# flux d’erreur standard ">>" (sortie normal) vs. 2> (canal d’erreur)
cd ~
lsd > sortie.txt 2> erreur.txt
# exercice : transformer tous les n en N d'un fichier et l'enregistrer dans un autre fichier
tr "n" "N" < test.txt > testN.txt
cat testN.txt
# Exercice : majusculiser les données
tr "[[:lower:]]" "[[:upper:]]" < test.txt
```

<center><font size="3" color="blue">2. Redirection du flux d’information</font></center>
<br>
Récupérer l’output de la première commande et le réenvoyer à la deuxième commande - symbole clé : pipe |

```{bash echo = TRUE}
# transformer "é" en "E" puis majusculiser l'output de la première commande
cd ~
tr "é" "E" < test.txt | tr "[[:lower:]]" "[[:upper:]]"
# trier par le premier champ - sort ; filtrage de doublons - uniq
egrep -o "\w+" test.txt | sort | uniq -c
```


<center><font size="3" color="blue">3. Sectionner les données par champ (un champ est defini par un symbole qui delimite ce champ particulier)</font></center>

```{bash echo = TRUE}
# couper les données en 2 champs par le délimiteur "="
cd ~
echo "la somme de 2+2=4" > test2.txt
cut -f2 -d"=" test2.txt
# utiliser read pour capturer la saisie de l'utilisateur et la stocker dans une variable
echo "nom ?" ; 
# read nom;
echo "bonjour $nom"
```
nom ?

wang

bonjour wang

## 09/10/19 - Préparation du projet

<center><font size="3" color="blue"><center><font size="3" color="blue">Configuration du terrain
</font></center></font></center>
<br>

* Nous avons créé l'arborescence de travail à l'aide du script bash suivant nommé 'prepare-environnement-projet.sh'
```{bash eval=FALSE}
#!/bin/bash
mkdir PROJET_MOT_SUR_LE_WEB
cd PROJET_MOT_SUR_LE_WEB
# on peut desormais creer l'arborescence de travail
mkdir ./CONTEXTES;
mkdir ./DUMP_TEXT;
mkdir ./IMAGES;
mkdir ./PAGES_ASPIREES;
mkdir ./PROGRAMMES;
mkdir ./TABLEAUX;
mkdir ./URLS;
# les lignes precedentes peuvent tenir sur une seule ligne
# a savoir mkdir ./CONTEXTES ./DUMP_TEXT etc....
# le dossier URLS contiendra le fichier initial d'URLs
````

* Il suffit de nous positionner dans le même répertoire que ce script et l'exécuter avec bash

```{bash eval=FALSE}
bash prepare-environnement-projet.sh
```

<center><font size="3" color="blue"><center><font size="3" color="blue">Etape 1 : lire les fichiers URL et écrire leurs contenus ligne par ligne dans un nouveau fichier</font></center></font></center>
<br>
_J'ai une remarque sur la manière dont on utilise pour récupérer tous les fichiers dans un répertoire. J'ai utilisé /chemin/* au lieu de $(ls /chemin) car ce dernier m'apparaît un peu lourd mais je vois pas leur différence au niveau de sortie_

```{bash eval=FALSE}
# !/bin/bash
# on commence par effacer l'éventuel contenu de ficher que l'on doit réécrire
echo "" > "$2/tableau.html";
# on récupère les 2 arguments que l'on a passé au programme
# le premier : chemin vers le dossier contenant les fichiers d'URL
# le second : chemin vers le dossier devant contenir le fichier HTML final
echo "les urls sont dans : $1";
echo "chemin de stockage : $2";
# pour tous les fichiers dans le répertoire 1
for fichier in $1/*
# on exécute les commandes suivantes
do
# compteur destiné à compter les URLs pour chaque fichier d'URL
compteur=1;
echo "$fichier";
  for ligne in $(cat "$fichier")
  do 
  echo "$compteur : $ligne" >> "$2/tableau.html";
  # on incrémente le compteur des URLs
  compteur=$((compteur+1))
  done
done
```